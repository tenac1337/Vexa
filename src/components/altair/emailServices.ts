import { EmailResponse, EmailDetail } from './types';
import { GOOGLE_API_KEY } from './constants';

/**
 * Enhanced Email Generation using Gemini (Stylized HTML)
 */
class EmailContentGenerator {
  private apiKey: string;

  constructor() {
    this.apiKey = 'AIzaSyAHcvCVIFJEBF0Jft1zrM1sZwPS1ff90MA';
  }

  async generateEmailContent(context: {
    recipient?: string;
    subject?: string;
    purpose?: string;
    content?: string;
    additionalContext?: string;
  }): Promise<{ success: boolean; subject?: string; body?: string; htmlBody?: string; error?: string }> {
    try {
      const prompt = this.createEmailPrompt(context);
      
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 1.0,
            
            topP: 0.95,
            maxOutputTokens: 8192,
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH", 
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
        throw new Error('No content generated by Gemini');
      }

      const generatedText = data.candidates[0].content.parts[0].text;
      return this.parseEmailContent(generatedText);

    } catch (error) {
      console.error('Error generating email content:', error);
      return {
        success: false,
        error: `Failed to generate email: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  private createEmailPrompt(context: {
    recipient?: string;
    subject?: string;
    purpose?: string;
    content?: string;
    additionalContext?: string;
  }): string {
    const recipient = context.recipient || 'the recipient';
    return `
    
    **Persona:** You are PiMail, an expert AI assistant specializing in crafting perfect emails. Your identity is that of a helpful, creative, and highly competent email writer and designer. Your responses are ALWAYS directly in the requested email format, without any conversational text or explanations.

    **Primary Directive:** Your task is to analyze the provided context and generate one of two types of emails on behalf of "Tarun":
    1.  A **Casual Professional Email**: Clean, well-formatted plain text.
    2.  A **Designed HTML Email**: A visually rich, beautifully designed HTML email.

    **--- Input Context You Must Analyze ---**
    - Recipient: ${recipient}
    - Subject: ${context.subject || 'Not specified'}
    - Purpose: ${context.purpose || 'General correspondence'}
    - Content: ${context.content || 'No specific content provided'}
    - Additional Context: ${context.additionalContext || 'None'}

    **--- Decision Logic ---**
    1.  **Generate a Designed HTML Email IF** the purpose or content clearly involves an **invitation, event, party, celebration, holiday greeting, or a special announcement.**
    2.  **Generate a Casual Professional Email IF** the purpose is for routine professional or personal correspondence, such as **meetings, tasks, questions, updates, reminders, follow-ups, or general communication.**

    ---

    **PATH 1: [CRITICAL] Instructions for a Casual Professional Email**
    If you determine the request is for a casual professional email, you must follow these rules with extreme precision. The structure is non-negotiable.

    - **Format:** The output must be 100% plain text. No HTML, no Markdown, no styling.
    - **Tone:** Friendly, clear, and professional but not overly formal. Match Tarun's casual style.

    **[VERY IMPORTANT] Email Structure Rules:**

    1.  **Salutation:**
        - Start with a proper greeting (e.g., "Hi", "Hello").
        - Address the recipient by name. If the recipient context is an email like 'jane.doe@example.com', use their first name ('Jane'). If a full name is given, use the first name.
        - The salutation must end with a comma and be on its own line.
        - **Example:** "Hi Jane,"

    2.  **Opening Line Break:**
        - After the salutation line, there MUST be **one single blank line**.

    3.  **Email Body:**
        - Write the main content of the email.
        - Keep paragraphs short (2-4 sentences).
        - Each paragraph MUST be separated from the next by **one single blank line**.

    4.  **Closing Line Break:**
        - After the final paragraph of the body, there MUST be **one single blank line**.

    5.  **Sign-off:**
        - On a new line, write a closing phrase (e.g., "Best,", "Thanks,", "Cheers,"). The comma is required.
        - This closing phrase MUST be on its own line.
        - **Example:** "Best,"

    6.  **Signature:**
        - On the very next line immediately after the closing phrase, write the name "Tarun".
        - **Example:** "Tarun"

    **Visual Example of the Required Structure:**

    Hi [Recipient Name],
    
    [This is the first paragraph of the email body. It's clear and concise.]
    
    [This is the second paragraph, separated from the first by a blank line.]
    
    Best,
    Tarun


    ---

    **PATH 2: Instructions for a Designed HTML Email**
    If you determine the request is for a designed invitation or announcement, follow these rules precisely:

    **[CRITICAL RULE] Your output for the body MUST be raw HTML.** It must start with \`<!DOCTYPE html>\` and end with \`</html>\`. DO NOT wrap the HTML code in Markdown fences like \`\`\`html.

    **Design & Content Rules:**
    1.  **Inline CSS is Mandatory:** All styling must be inline CSS within the HTML tags (e.g., \`<p style="...">\`).
    2.  **No Image Tags:** Absolutely no \`<img>\` tags or external image URLs.
    3.  **Use Inline SVG for Graphics:** All graphics, icons, and visual elements MUST be created using inline SVG. This includes decorative elements, icons (like a calendar or location pin), and animations.
    4.  **Rich & Modern Design:** Use gradients [IMPORTANT], box-shadows, modern fonts (websafe), and varied colors to create a visually stunning email that looks professional and festive.
    5.  **Mobile-First:** The design must be responsive and look perfect on mobile devices and in Gmail. Use a single-column layout with a max-width (e.g., 600px).
    6.  **Signature Placement:** The closing (e.g., "Can't wait to see you there!") and the name "Tarun" **MUST be inside the main styled content block of the HTML** to ensure they are styled correctly with the rest of the email body.
    7.  **Footer:** At the very bottom of the email content, centered, include a small, elegantly styled footer that says: \`Designed with ❤️ by Pi\`

    [VERY IMPORTANT]
    Make it as beautiful as possible. You are a graphic designer, and you are a master of design.
    Use icons, graphics, animations, and other visual elements to make it more engaging and beautiful.
    Use gradients, box-shadows, and other modern design elements to make it more engaging and beautiful.
    Adapt the design to the content of the email.
    ---

    **[FINAL OUTPUT STRUCTURE]**
    You must provide the final output in the following strict format. There should be nothing before "Subject:".

    Subject: [Generated Subject Line]
    ---
    [The Raw Email Body: Either Plain Text for Path 1, or the Full Raw HTML for Path 2]

    **Begin Generation Now.**
    `;
  }

  private parseEmailContent(generatedText: string): { success: boolean; subject?: string; body?: string; htmlBody?: string; error?: string } {
    try {
      const lines = generatedText.split('\n');
      let subject = '';
      let body = '';
      let foundSeparator = false;
      let isHtmlEmail = false;

      for (const line of lines) {
        if (line.startsWith('Subject:')) {
          subject = line.replace('Subject:', '').trim();
        } else if (line.includes('---')) {
          foundSeparator = true;
        } else if (foundSeparator) {
          // Check if this is an HTML email
          if (line.trim().startsWith('<!DOCTYPE html>')) {
            isHtmlEmail = true;
          }
          body += line + '\n';
        }
      }

      // Fallback parsing if the format is different
      if (!subject || !body.trim()) {
        const subjectMatch = generatedText.match(/Subject:\s*(.+)/i);
        if (subjectMatch) {
          subject = subjectMatch[1].trim();
          body = generatedText.replace(/Subject:\s*(.+)/i, '').replace(/---/g, '').trim();
        } else {
          const allLines = generatedText.trim().split('\n');
          subject = allLines[0] || 'Generated Email';
          body = allLines.slice(1).join('\n').trim();
        }
      }

      // For HTML emails, both body and htmlBody are the same
      // For plain text emails, preserve line breaks and structure
      if (isHtmlEmail) {
        return {
          success: true,
          subject: subject || 'Generated Email',
          body: body.trim(),
          htmlBody: body.trim()
        };
      } else {
        // For plain text emails, ensure proper line breaks
        const formattedBody = body
          .split('\n')
          .map(line => line.trim())
          .filter(line => line)  // Remove empty lines
          .join('\n\n');  // Add double line breaks between paragraphs
        
        return {
          success: true,
          subject: subject || 'Generated Email',
          body: formattedBody,
          htmlBody: undefined
        };
      }
    } catch (error) {
      return {
        success: false,
        error: `Failed to parse generated email: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
}

// Create a singleton instance
const emailGenerator = new EmailContentGenerator();

/**
 * Enhanced email sending with Gemini stylized HTML content generation
 */
export async function sendEnhancedEmail(
  to: string,
  context: {
    subject?: string;
    purpose?: string;
    content?: string;
    additionalContext?: string;
  }
): Promise<EmailResponse> {
  try {
    console.log('🤖 Generating stylized HTML email with Gemini...');
    
    // Generate email content using Gemini
    const generationResult = await emailGenerator.generateEmailContent({
      recipient: to,
      ...context
    });

    if (!generationResult.success) {
      return {
        success: false,
        error: generationResult.error || 'Failed to generate email content'
      };
    }

    console.log('✅ Stylized HTML email content generated successfully');
    console.log('📧 Subject:', generationResult.subject);
    
    // Send the generated email
    return await sendEmail(
      to,
      generationResult.subject!,
      generationResult.body!,
      generationResult.htmlBody
    );

  } catch (error) {
    console.error('Error in enhanced email sending:', error);
    return {
      success: false,
      error: `Enhanced email sending failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    };
  }
}

/**
 * Creates a MIME message string for an email with both plain text and HTML parts.
 */
export function createMimeMessage(to: string, from: string, subject: string, body: string, htmlBody?: string): string {
  const boundary = 'foo_bar_baz';
  const emailLines = [];
  
  // Headers
  emailLines.push(`From: <${from}>`);
  emailLines.push(`To: <${to}>`);
  emailLines.push('MIME-Version: 1.0');
  emailLines.push(`Subject: ${subject}`);
  
  if (htmlBody) {
    // Multipart message
    emailLines.push(`Content-Type: multipart/alternative; boundary=${boundary}`);
    emailLines.push('');
    
    // Plain text part
    emailLines.push(`--${boundary}`);
    emailLines.push('Content-Type: text/plain; charset=UTF-8');
    emailLines.push('Content-Transfer-Encoding: 7bit');
    emailLines.push('');
    emailLines.push(body);
    emailLines.push('');
    
    // HTML part
    emailLines.push(`--${boundary}`);
    emailLines.push('Content-Type: text/html; charset=UTF-8');
    emailLines.push('Content-Transfer-Encoding: 7bit');
    emailLines.push('');
    emailLines.push(htmlBody);
    emailLines.push('');
    
    // End boundary
    emailLines.push(`--${boundary}--`);
  } else {
    // Simple plain text message
    emailLines.push('Content-Type: text/plain; charset=UTF-8');
    emailLines.push('Content-Transfer-Encoding: 7bit');
    emailLines.push('');
    emailLines.push(body);
  }

  const email = emailLines.join('\r\n');
  // Unicode-safe base64 encoding
  return btoa(unescape(encodeURIComponent(email))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

export async function sendEmail(to: string, subject: string, body: string, htmlBody?: string): Promise<EmailResponse> {
  if (!(window as any).gapi.client.gmail) {
    return { 
      success: false, 
      error: "INTERNAL_ERROR", 
      message: "Gmail API module not loaded." 
    };
  }

  const rawMessage = createMimeMessage(to, "me", subject, body, htmlBody);
  try {
    const request = (window as any).gapi.client.gmail.users.messages.send({
      userId: 'me',
      resource: { raw: rawMessage }
    });
    const response: any = await request;
    return { 
      success: true, 
      message: `Email sent to ${to}.`, 
      messageId: response.result.id 
    };
  } catch (err: any) {
    const errorMessage = err.result?.error?.message || err.message || "Unknown error sending email.";
    if (err.status === 401) {
      return { 
        success: false, 
        error: "NEEDS_REAUTHORIZATION", 
        message: `Gmail auth error (${errorMessage}). Please re-authorize.` 
      };
    }
    return { 
      success: false, 
      error: `Failed to send email: ${errorMessage}` 
    };
  }
}

export async function readLatestEmails(count: number = 3): Promise<EmailResponse> {
  if (!(window as any).gapi.client.gmail) {
    return { 
      success: false, 
      error: "INTERNAL_ERROR", 
      message: "Gmail API module not loaded." 
    };
  }

  const maxResults = Math.min(Math.max(1, count), 10); // Default 3, min 1, max 10
  try {
    const listResponse: any = await (window as any).gapi.client.gmail.users.messages.list({
      userId: 'me',
      labelIds: ['UNREAD', 'INBOX'], // Focus on unread in inbox
      maxResults: maxResults,
      q: 'is:unread' // Query for unread messages
    });

    const messages = listResponse.result.messages || [];
    if (messages.length === 0) {
      return { 
        success: true, 
        message: "No new unread emails found.", 
        emails: [] 
      };
    }

    const emailDetailsPromises = messages.map((msg: { id: string }) =>
      (window as any).gapi.client.gmail.users.messages.get({
        userId: 'me',
        id: msg.id,
        format: 'metadata', // We only need headers for this summary
        metadataHeaders: ['Subject', 'From', 'Date']
      })
    );
    
    const emailResponses: any[] = await Promise.all(emailDetailsPromises);
    const fetchedEmails: EmailDetail[] = emailResponses.map(res => {
      const payload = res.result.payload;
      const headers = payload.headers;
      const getHeader = (name: string) => headers.find((h: any) => h.name.toLowerCase() === name.toLowerCase())?.value || 'N/A';
      return {
        id: res.result.id,
        threadId: res.result.threadId,
        subject: getHeader('Subject'),
        from: getHeader('From'),
        date: getHeader('Date'),
        snippet: res.result.snippet, // Short part of the message
      };
    });
    
    return { 
      success: true, 
      emails: fetchedEmails, 
      message: `Fetched ${fetchedEmails.length} email(s).` 
    };

  } catch (err: any) {
    const errorMessage = err.result?.error?.message || err.message || "Unknown error reading emails.";
    if (err.status === 401) {
      return { 
        success: false, 
        error: "NEEDS_REAUTHORIZATION", 
        message: `Gmail auth error (${errorMessage}). Please re-authorize.` 
      };
    }
    return { 
      success: false, 
      error: `Failed to read emails: ${errorMessage}` 
    };
  }
} 